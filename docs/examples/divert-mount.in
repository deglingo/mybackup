#!@SHELL@

set -eu

_MYPID=$$
trace() { echo "divert-mount: $*" >&2; }
warning() { echo "divert-mount:WARNING: $*" >&2; }
error() { echo "divert-mount:ERROR: $*" >&2; }
die() { echo "divert-mount:FATAL: ${@:-aborting}" >&2; kill -ABRT $_MYPID; }

# usage
usage()
{
	cat <<EOF
USAGE: divert-mount [OPTIONS] COMMAND...

OPTIONS:

  -u UUID  select the device by UUID
  -d DIR   destination dir (mount point, must exist)
  -t TYPE  device type
  -o OPTS  mount options
  -h       print this message and exit
EOF
}

# main
main()
{
	# parse command line
	DEV=
	OPTS=`getopt -n divert-mount -o "u:d:t:o:h" -- "${@}"` || die "?"
	eval set -- "$OPTS"
	while true; do
		case "$1" in
			-h) usage; exit 0;;
			-u) DEV="/dev/disk/by-uuid/$2"; shift 2;;
			-d) MNTDIR="$2"; shift 2;;
			-t) DEVTYPE="$2"; shift 2;;
			-o) MNTOPTS="$2"; shift 2;;
			--) shift; test $# -gt 0 || die "COMMAND required"; break;;
			*) die "? $1";;
		esac
	done
	# check required args
	test x"$DEV" != x || die "device required (-u)"
	test -e "$DEV" || die "device not found: '$DEV'"
	test x"$MNTDIR" != x || die "mntdir required (-d)"
	test -d "$MNTDIR" || die "mntdir does not exist: '$MNTDIR'"
	# set defaults
	: ${DEVTYPE:=auto}
	: ${MNTOPTS:=rw}
	# build command
	COMMAND="\"$1\""; shift
	while test $# -gt 0; do
		COMMAND="$COMMAND \"$1\""
		shift
	done
	# debug
	# trace "FSTAB:"
	# _mtab </etc/fstab >&2
	# trace "MOUNT:"
	# mount | _mtab >&2
	# go
	process && trace "all done!" || die "errors in process"
}

# process
process()
{
	_umount "$DEV" || return 1
	_mount "$DEV" "$MNTDIR" "$DEVTYPE" "$MNTOPTS" || return 1
	trace "`pwd`> $COMMAND"
	R=0; ( eval "$COMMAND"; ) || R=$?
	trace "command terminated: $R"
	_remount "$DEV" || {
		error "could not remount device '$DEV'";
		R=126; } # ?
	return $R
}

# _fixdev DEV
_fixdev()
{
	local d=`readlink -e "$1"` && test x"$d" != x || { 
		error "invalid device: '$1'";
		return 1; }
	test -e "$d" || {
		error "device not found: '$1'";
		return 1; }
	#trace "fixdev: '$1' -> '$d'"
	echo "$d"
	return 0
}

# _mtab
_mtab()
{
	e="# strip
       s,[\t], ,g;
       s,^[ ]*,,g;
	   s,[ ]*$,,g;
       # replace UUID= and LABEL= forms
       s,^UUID=,/dev/disk/by-uuid/,g;
       s,^LABEL=,/dev/disk/by-label/,g;
       # skip comments, empty and system devs
       /^#/d
       /^$/d
       /^[^/]/d"
	local l d
	sed -e "$e" | while read l; do
		d=`echo "$l" | cut -d' ' -f1`
		d=`readlink -e "$d"` && test -e "$d" || continue
		echo "$d"
	done
}

# _ismounted DEV
_ismounted()
{
	local dev=`_fixdev "$1"` || return 1
	local d
	#trace "ismounted: '$dev'"
	for d in `mount | _mtab | awk '{print $1}'`; do
		test x"$d" != x"$dev" || {
			#trace "YES";
			return 0; }
	done
	#trace "NO"
	return 1
}

# _umount DEV
_umount()
{
	local dev=`_fixdev "$1"` || return 1
	_ismounted "$dev" || return 0
	trace "unmounting '$dev'"
	if umount "$dev"; then
		trace "OK"
		return 0
	fi
	error "could not unmount '$dev' - trying lazy mode"
	if umount -l "$dev"; then
		trace "OK"
		warning "device '$dev' unmounted in lazy mode !?"
		return 0
	fi
	error "could not unmount '$dev'"
	return 1
}

# _mount DEV DEST TYPE OPTS
_mount()
{
	local dev=`_fixdev "$1"` || return 1
	local dest="$2" type="$3" opts="$4"
	trace "mounting '$dev' ($type) on '$dest' ($opts)"
	if mount "$dev" "$dest" -t "$type" -o "$opts"; then
		trace "OK"
		return 0
	else
		error "could not mount '$dev'"
		return 1
	fi
}

# _remount
_remount()
{
	local dev=`_fixdev "$1"` || return 1
	local d
	_umount "$dev" || return 1
	for d in `_mtab </etc/fstab`; do
		if test x"$d" = x"$dev"; then
			trace "remounting '$dev'"
			if mount "$dev"; then
				trace "OK"
				return 0
			else
				error "could not remount '$dev'"
				return 1
			fi
		fi
	done
	trace "device '$dev' not configured in fstab"
}

# exec
main "${@}"
